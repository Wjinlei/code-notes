<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>闭包</title>
</head>
<body>

<script>
    // 先看下面函数,分析执行流程
    function t1() {
        var age = 20;
        function t2() {
            alert(age);
        }
        return t2;
    }
    var tmp = t1();
    var age = 99;
    tmp(); // 20

    // 上面的结果等于 20 这是为什么?
    // 先看第一句: var tmp = t1();
    // 这句话的意思就是把t1执行的结果,也就是返回值赋给变量tmp。没意见吧? 那么此时tmp是不是就等于t2 ?

    // 第二句: var age = 99;
    // 给age赋值99

    // 再看第三句: tmp();
    // 执行tmp,相当于就是执行t2,这没意见吧? 那么主要的争议点就是这句话

    // 如果按其他语言的理解,例如C语言。我们知道一个函数在执行结束后,它的局部变量就被销毁(填充CC)
    // 那么t1在执行完毕后,age=20就被销毁了,接着它把t2返回去。那么到这里执行t2的时候(此时t2和t1没有任何关系),它肯定就
    // 找不到age=20,所以按照作用域的理解,它应该向外部找,直到在全局找到age=99,所以应该打印99

    // 但是结果却不是我们预想的那样,结果并不是99,而是20。证明它找到了age=20,这是为什么呢? 它从哪里找到的?
    // 答:因为在js中,对于这种情况,返回的函数并非一个孤立的函数,而是和周围环境有关系的函数。
    // 例如: 在本例中, t2并非一个孤立的函数,它是和t1有关系的。因为t1在返回t2时,会把自身的所有成员和变量,
    // 与这个函数一起打个"包"共同返回,但是这些成员和变量只有t2可以访问,所以叫做"闭包"
    // 它是一个封闭的"环境包"

    // 再看下面的例子:
    function t3() {
        var age=30;
        function t4() {
            t5();
        }
        function t5() {
            alert(age);
        }
        return t4;
    }
    var tmp2 = t3();
    var age = 100;
    tmp2(); // 30

    // 可以看到t3在返回t4时,不仅把age=30打了包,连function t5也一起打了包。

    // 总结:
    // 一个函数在返回其内部的另一个函数时,会把自身的所有成员和变量,与这个被返回的函数一起打个"包"共同返回

</script>
</body>
</html>