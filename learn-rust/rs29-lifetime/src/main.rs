// https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html
// 得反复看,反正我第一遍是没看懂
fn main() {
    // 总结:
    // 生命周期解决了什么问题? 答:避免了悬垂引用
    // 它怎么避免这个问题?
    // 当你函数返回一个引用的时候，你需要告诉Rust，参数的生命周期和返回值的生命周期
    // 因为你函数中不可能返回一个内部引用嘛(因为所有权,会被释放)，所以返回值肯定是和参数有关联的
    // 你返回的是你传入的参数的引用，所以你要保证返回的引用绝对有效，那么你就必须指明参数和返回值的生命周期关系。
    // 这是一种规则，好让Rust按照这种规则进行检查，如果不通过则编译报错
    //
    // 考虑一下这个问题在其他语言中的样子，例如c++，当你一个函数接收一个参数x的引用，
    // 函数体中返回这个x的引用，如果x引用的内存在函数返回前就释放掉了，那这个函数
    // 岂不是会返回一个无效的引用? 这就造成了悬垂引用。
    //
    // 但这在Rust中是不允许的，例如我指明参数x的生命周期是'a，返回值的生命周期也是'a
    // 那么Rust在编译时就会检查，你传入的x在函数返回之前是否是一定有效的，如果不是
    // 则编译不通过。
    //
    let string1 = String::from("long string is long");
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("The longest string is {}", result);
}

// 现在让我们来编写一个返回两个字符串 slice 中较长者的函数。
// 这个函数获取两个字符串 slice 并返回一个字符串 slice。
/*
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
*/
// 这个函数看上去没问题，但Rust不允许通过
// 因为你没有指明参数的生命周期和返回值之间的关系
// Rust无法判断传入的引用是否还有效，因为它不知道 x 和 y 的生命周期是如何与返回值的生命周期相关联的。

// 所以为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。
// 生命周期注解语法:
// &'a i32     // 带有显式生命周期 'a 的引用
// &'a mut i32 // 带有显式生命周期的 'a 可变引用
// 单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。

// 我们把它用在泛型函数上就好了,下面是longest函数的修复版
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
// 这样就限定了参数x，y,和返回值都必须在同一个生命周期中
// 什么意思呢？ 比如你在一个代码块中调用此函数，那么这个函数的返回值
// 的生命周期就是这个代码块，那么你的参数x和y也必须是在这个代码块中有效才行
// 这样就解决了悬垂引用问题
