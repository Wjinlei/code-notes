// 最简单直接的智能指针是 box，其类型是 Box<T>。
// box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。

// 除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：
// 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
// 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
// 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候

/*
enum List1 {
    Cons(i32, List1),
    Nil,
}
*/

// 演示第一种场景: 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
enum List2 {
    Cons(i32, Box<List2>),
    Nil,
}

fn main() {
    // 使用 Box<T> 在堆上储存数据
    let b = Box::new(5);
    println!("b = {}", b);

    // 第一个 Cons 储存了 1 和另一个 List 值。
    // 这个 List 是另一个包含 2 的 Cons 值和下一个 List 值。
    // 接着又有另一个存放了 3 的 Cons 值和最后一个值为 Nil 的 List，非递归成员代表了列表的结尾。

    // 下面的代码不能编译，因为Rust不知道需要多少空间
    //let list = List1::Cons(1, List1::Cons(2, List1::Cons(3, List1::Nil)));

    // 利用Box智能指针就可以定义了
    List2::Cons(1,Box::new(List2::Cons(2, Box::new(List2::Cons(3, Box::new(List2::Nil))))));
}
