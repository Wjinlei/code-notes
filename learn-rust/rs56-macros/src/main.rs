// 宏就像类型别名一样，它不是一个新的东西，它在编译前会被展开为原来的东西
//
// 计算机科学里的宏（Macro)，是一种批量处理的称谓。
// 一般说来，宏是一种规则或模式，或称语法替换 ，
// 用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。
// 这种替换在预编译时进行，称作宏展开。
//
// 所有的这些宏以展开的方式来生成比你所手写出的更多的代码。
// 元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数扮演的角色。但宏有一些函数所没有的附加能力。
//
// 宏可以在编译器翻译代码前展开
// 实现一个宏要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。
// 由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。
//
// Rust中宏分为：使用 macro_rules! 的声明（Declarative）宏，和三种过程（Procedural）宏：
//
// Rust 最常用的宏形式是 声明宏（declarative macros）。
// 它们有时也被称为 “macros by example”、“macro_rules! 宏” 或者就是 “macros”。
// 其核心概念是，声明宏允许我们编写一些类似 Rust match 表达式的代码。
// match 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。
// 宏也将一个值和包含相关代码的模式进行比较；
// 此种情况下，该值是传递给宏的 Rust 源代码字面值，模式用于和传递给宏的源代码进行比较，
// 同时每个模式的相关代码则用于替换传递给宏的代码。所有这一切都发生于编译时。



// 1.声明宏(declarative)
// 可以使用 macro_rules! 来定义宏。
// 让我们通过查看 vec! 宏定义来探索如何使用 macro_rules! 结构。
// 注意：标准库中实际定义的 vec! 包括预分配适当量的内存的代码。这部分为代码优化，为了让示例简化，此处并没有包含在内。
//
// 无论何时导入定义了宏的包，#[macro_export] 注解说明宏应该是可用的。 如果没有该注解，这个宏不能被引入作用域。
#[macro_export]
macro_rules! vec {
    // 接着使用 macro_rules! 和宏名称开始宏定义，且所定义的宏并 不带 感叹号。
    // 名字后跟大括号表示宏定义体，在该例中宏名称是 vec 。
    ( $( $x:expr ),* ) => {
    // vec! 宏的结构和 match 表达式的结构类似。此处有一个单边模式 ( $( $x:expr ),* ) ，后跟 => 以及和模式相关的代码块。
    //
    // 首先，一对括号包含了整个模式。
    // 接下来是美元符号$，后跟一对括号，捕获了符合括号内模式的值以用于替换代码。
    //
    // $() 内则是 $x:expr ，其匹配 Rust 的任意表达式，并将该表达式记作 $x。
    //
    // $() 之后的逗号说明一个可有可无的逗号分隔符可以出现在 $() 所匹配的代码之后。
    // 紧随逗号之后的 * 说明该模式匹配零个或更多个 * 之前的任何模式。
    // 所以对于这个宏，它的模式是 $( $x:expr ) 它可以匹配多个
    //
    // 当以 vec![1, 2, 3]; 调用宏时，$x 模式与三个表达式 1、2 和 3 进行了三次匹配。
    // 这个宏展开来就像这样
    /*
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    */
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

// 2.过程宏
// 第二种形式的宏被称为 过程宏（procedural macros），因为它们更像函数（一种过程类型）。
// 过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，
// 而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。
//
// 过程宏给我的第一印象有点像Java中的注解
//
// 有三种类型的过程宏，不过它们的工作方式都类似。
//   2.1 自定义派生(derive)
//   2.2 类属性
//   2.3 类函数
// 当创建过程宏时，其定义必须位于一种特殊类型的属于它们自己的 crate 中。
// 这么做出于复杂的技术原因，将来我们希望能够消除这些限制。

// 下面演示自定义派生宏(derive)
// 请参考hello_macro
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
